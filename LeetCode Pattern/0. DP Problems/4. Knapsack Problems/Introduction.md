# Knapsack Problems 背包问题

本专题做的实在是头疼啊, 经过了一个礼拜, 九道题还是没法吃透. 先来进行技术总结. 但是不要总结什么组合优化, NP-comp, NP-hard这些鬼东西了. 看了下背景, 知道背包问题是算法竞赛里面常见的题目, 数学特性非常浓烈. 

本专题由于本人都还没弄得很透彻, 大部分理解和解题思路都来源于ref的两个帖子. 其中ref #1对问题的分类整理讲解的十分透彻. LC上总共有>11道背包问题, 解题模板的特征还是相对明显的. 我的笔记只能作为你在熟悉了问题, 看完了教程, 做了题目之后, 再来看的一个总结. 这个笔记没有对背包问题进行非常细致的归纳. 

## **Problem Description**

有一个背包, 它的总容量为 **W**

有n个不同属性的物件, 他们分别有 **w[i]** 的重量和 **v[i]** 的价值. (实际题目当中, 基本重量都**等于**价值).

题目常见的三个问题方向:

1. 求放入背包当中最大的物品总价值 或 达到某价值的最少物品数量 (最值问题, 原始的背包问题)
2. 求是否存在可以恰好填入背包的组合 (存在问题, 很多LC题目是这类)
3. 求所有满足填放背包的方案个数 (方案个数, 即存在问题的变种)

它们对应的状态转移方程十分类似, 但对初始状态的选择, 和空间优化过后的状态遍历需要十分讲求(这方面是我做每一题时最大的困难, 有时候要正序, 有时候倒序, 有时候内外循环颠倒...)

## **Formulate Problems**

定义问题以及DP当中要素, 状态转移, 初始状态, 构建DP的循环, 是这个章节的难点. 很多帖子都是从原始的二维DP状态来定义, 但所有题目的答案都几乎是空间优化过后的一维DP, 这也是导致了跟着很多帖子视频学过来, 但是发现自己解题上手十分晦涩. 但在此归纳, 还是要从二维DP入手, 要不然实在想不清一维解答的构成.

本质上, 所有背包问题都涉及到两个状态变量. 第一维度是**物品**, 通常需要我们遍历输入的所有物品及他们的属性. 第二维度是**容量**, 这个维度才是所有所有所有背包问题的关键. 通常背包问题都有一个背包总价值, 诸如, 所有硬币之和, 挑选的数字之和等等表述. 而精髓就在于, 通过DP来一步步地状态转移至这个解. 所以基本所有背包问题的返回值都是 DP[n][capicity] 或 DP[capacity] (空间优化之后)

```py
def knapsacks (items, target):
  n = len(items)      # 总共物品数
  capacity = xxx      # 根据题目要求不同构建, 通常它为输入的 target

  # 创建二维DP数组 (通常都以capacity初始化为一维数组)
  # DP的每个维度都比该变量的实际大小大出一位, 以符合初始化以及方便的索引
  # 对DP[i][j]的值, 不同类别的题目创建元素为不同, 常为 -INF, 0, 或 INF
  DP = [[0] * (capacity+1) for _ i in range(n+1)]

  # 初始化 i=0 的所有值
  # 通常对不同题目初始化 i=0 时常用 0, 或 items[0]
  DP[0][j] = xxx

  # 遍历两个维度
  # 不同类型的题目可能需要颠倒内外循环
  # 绝大多数题目, 外层循环items, 内层循环capacity
  for i in range(1, n):
    # 取出当前物品/钱币/数字...
    item = items[i-1]
    for j in range(1, capacity+1):
      # 注意在内层循环内避开可能的indexing越界情况
      if indexing condition:
        DP[i][j] = max(DP[i-1][j], DP[i-1][j-item]+value)

  # 通常输出值代表: 取出最多n个物品时, 达到题目要求capacity的最优解
  return DP[n][capacity]

```

## References
- https://leetcode-cn.com/problems/coin-change/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-sq9n/
- https://zhuanlan.zhihu.com/p/93857890 