# Knapsack Problems 背包问题

本专题做的实在是头疼啊, 经过了一个礼拜, 九道题还是没法吃透. 先来进行技术总结. 但是不要总结什么组合优化, NP-comp, NP-hard这些鬼东西了. 看了下背景, 知道背包问题是算法竞赛里面常见的题目, 数学特性非常浓烈. 

本专题由于本人都还没弄得很透彻, 大部分理解和解题思路都来源于ref的两个帖子. 其中ref #1对问题的分类整理讲解的十分透彻. LC上总共有>11道背包问题, 解题模板的特征还是相对明显的. 我的笔记只能作为在熟悉了问题, 看完了教程, 做了题目之后, 再来看的一个总结. 这个笔记没有对背包问题进行非常细致的归纳. 

## **Problem Description**

有一个背包, 它的总容量为 **W**

有n个不同属性的物件, 他们分别有 **w[i]** 的重量和 **v[i]** 的价值. (实际题目当中, 基本重量都**等于**价值).

题目常见的三个问题方向:

1. 求放入背包当中最大的物品总价值 或 达到某价值的最少物品数量 (最值问题, 原始的背包问题)
2. 求是否存在可以恰好填入背包的组合或方案个数 (存在问题, 很多LC题目是这类)
3. 求所有满足条件填满背包的排列 (排列问题影响到构建DP的循环顺序)

它们对应的状态转移方程十分类似, 但对初始状态的选择, 和空间优化过后的状态遍历需要十分讲求(这方面是我做每一题时最大的困难, 有时候要正序, 有时候倒序, 有时候内外循环颠倒...)

## **Problem Classification**
背包问题显著体现在有具体的背包分类和问题类型分类(上面写的三个方向), 其中背包分类在数学上有严格定义

1. **0/1 Knapsack**: 0/1 背包问题, 选取的物品最多只能使用一次. 这是一个NP-Complete问题
2. **Unbounded Knapsack**: 无限背包问题, 每个物品可以选取多次, 例如从1,2,5,10四种不同的硬币当中选取组合满足总和为22元的可能. 这是一个NP-hard问题.

以上是背包的两大分类, 除此之外还有**Bounded Knapsack**. 有限背包问题, 每种物品可以选取不超过特定次数, 通常转换为0/1背包问题, LC当中题目较少. 因此不再讨论. 而这两类问题, 和以上的三种问题类型分类结合起来, 总共有6种不同的题型. LC当中11道题全部属于这6种类别其中.

## **Formulate Problems**

定义问题以及状态转移, 初始状态, 构建DP的循环, 是这个章节的难点. 很多帖子都是从原始的二维DP状态来定义, 但所有题目的答案都几乎是空间优化过后的一维DP, 这也是导致了跟着很多帖子视频学过来, 但是发现自己解题上手十分晦涩. 但在此归纳, 还是要从二维DP入手, 要不然实在想不清一维解答的构成.

本质上, 所有背包问题都涉及到两个状态变量. 第一维度是**物品**, 通常需要我们遍历输入的所有物品及他们的属性. 第二维度是**容量**, 这个维度才是所有所有所有背包问题的关键. 通常背包问题都有一个背包总价值, 诸如, 所有硬币之和, 挑选的数字之和等等表述. 

背包问题的精髓就在于, **通过转移价值状态以达到容量**. 所以背包问题常见的特征包括

1. 返回值都是 DP[n][capicity] 或 DP[capacity] (空间优化之后)
2. 有两个循环, 通常外层循环可选物品, 内层循环容量单位
3. 状态转移时有诸如 DP[j] = DP[j-item] 的形式 (最明显的特征)

```py
def knapsacks (items, target):
  n = len(items)      # 总共物品数
  capacity = xxx      # 根据题目要求不同构建, 通常它为输入的 target

  # 创建二维DP数组 (通常都以capacity初始化为一维数组)
  # DP的每个维度都比该变量的实际大小大出一位, 以符合初始化以及方便的索引
  # 对DP[i][j]的值, 不同类别的题目创建元素为不同, 常为 -INF, 0, 或 INF
  DP = [[0] * (capacity+1) for _ i in range(n+1)]

  # 初始化 i=0 的所有值
  # 通常对不同题目初始化 i=0 时常用 0, 或 items[0]
  DP[0][j] = xxx

  # 遍历两个维度
  # 不同类型的题目可能需要颠倒内外循环
  # 绝大多数题目, 外层循环items, 内层循环capacity
  for i in range(1, n):
    # 取出当前物品/钱币/数字...
    item = items[i-1]
    for j in range(1, capacity+1):
      # 注意在内层循环内避开可能的indexing越界情况
      if indexing condition:
        # 不同类型题目的状态转移不同
        DP[i][j] = max(DP[i-1][j], DP[i-1][j-item]+value)

  # 通常输出值代表: 取出最多n个物品时, 达到题目要求capacity的最优解
  return DP[n][capacity]
```

## **Problem Template**
以上二维的解题思路可以作为思考此类问题的起始点, 实在不知道该怎么做时, 从上面模板起始可以避免空间优化过的一维问题的晦涩. 根据这一点, 本小节再来归纳出针对不同题型的一维状态转移方程.  

一维模板的特征是, 对初始值, 和遍历循环的顺序有极高的要求. 不同的题目可能有所不同. 一维DP消除了item这个维度 (DP[i][j]变为了DP[j]), 但在循环时, 依旧需要有两层循环. 因此导致不同问题, 为了保证建立DP时不覆盖掉之前计算的有用信息, 需要保证顺序. 具体请参考Ref #1 and #2.

首先, 根据三种不同的问题类型分类, 状态转移方程会有不同的表达形式

**最值问题**
```py
DP[j] = max(DP[j], DP[j-item] + item)   # 通常求最大价值
DP[j] = min(DP[j], DP[j-item] + 1)      # 通常求达到最大价值的最少数量
```

**存在,组合, 或排序问题**
```py
DP[j] = DP[j] + DP[j-item]    # 通常求达到某要求的组合数目 (或是否存在该组合)
```

根据背包问题的种类, 此处有个十分严格的规范, 就是
1. 0/1 背包问题, 外层循环items, 内层**倒序**循环capacity
2. 无限背包问题, 外层循环items, 内层**正序**循环capacity

**排序问题**

排序问题的状态转移方程, 和存在或组合问题一致. 但特殊性在于, 外层循环capacity, 内层循环items. 这点需要通过二维转一维时去做证明. (我还没做...)

这样做的原因是, 从二维优化到一维时, 循环顺序会影响到已求解是否可能被覆盖而定. 具体机制需要自己尝试单步调试一个问题, 从二维到一维, 观察变量修改的顺序. (*这种体会不要太深刻*) 在每一个题目的描述文档中, 我都对问题的分类进行了详细的描述. 

## **Summary**

总结这么多, 是两个礼拜来研究背包问题的心得体会. 跟开头讲的一样, 这份内容仅仅是体会. 需要先对reference当中的讲解来做理解, 然后尝试做一轮题目之后, 再回过头来看. 除此之外, 二维DP版本笔记好上手理解, 但所有题目解答都使用了空间优化, 因此导致对特定问题的循环先后以及顺序有严格的要求. 一下是所有问题的类型汇总, 在做的时候一定要先理解清楚问题类型再码

### **0/1 Knapsack**

- 416. Partition Equal Subset Sum: 存在组合问题
- 494. Target Sum: 存在组合问题
- 1049. Last Stone Weight II: 最值问题
- 474. Ones and Zeros: 最值问题, ***二维背包***
- 1155. Number of Dice Rolls with Target Sum: 排序组合问题, **分组背包**

### **Unbounded Knapsack**

- 322. Coin Change: 最值问题
- 279. Perfect Squares: 最值问题
- 518. Coin Change II: 存在组合问题
- 377. Combination Sum IV: 排序组合问题

## References
- https://leetcode-cn.com/problems/coin-change/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-sq9n/
- https://zhuanlan.zhihu.com/p/93857890 